[gd_scene load_steps=18 format=3 uid="uid://cdin4o633pip7"]

[ext_resource type="Script" uid="uid://yhiwa1kexu2o" path="res://scene/map_scene.gd" id="1_dhios"]
[ext_resource type="PackedScene" path="res://gun.tscn" id="1_pwi0h"]

[sub_resource type="Shader" id="Shader_03pub"]
code = "// NOTE: Shader automatically converted from Godot Engine 4.5.stable's StandardMaterial3D.

shader_type spatial;
render_mode blend_mix, depth_draw_always, cull_back, diffuse_burley, specular_schlick_ggx;

uniform vec4 albedo : source_color;
uniform sampler2D texture_albedo : source_color, filter_linear_mipmap, repeat_enable;
uniform ivec2 albedo_texture_size;
uniform float point_size : hint_range(0.1, 128.0, 0.1);

uniform float roughness : hint_range(0.0, 1.0);
uniform sampler2D texture_metallic : hint_default_white, filter_linear_mipmap, repeat_enable;
uniform vec4 metallic_texture_channel;
uniform sampler2D texture_roughness : hint_roughness_r, filter_linear_mipmap, repeat_enable;

uniform float specular : hint_range(0.0, 1.0, 0.01);
uniform float metallic : hint_range(0.0, 1.0, 0.01);

uniform sampler2D texture_refraction : filter_linear_mipmap, repeat_enable;
uniform float refraction : hint_range(-1.0, 1.0, 0.001);
uniform vec4 refraction_texture_channel;
uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_linear_mipmap;
uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest;

uniform sampler2D texture_normal : hint_roughness_normal, filter_linear_mipmap, repeat_enable;
uniform float normal_scale : hint_range(-16.0, 16.0);
varying vec3 uv1_triplanar_pos;

uniform float uv1_blend_sharpness : hint_range(0.0, 150.0, 0.001);
varying vec3 uv1_power_normal;

uniform vec3 uv1_scale;
uniform vec3 uv1_offset;
uniform vec3 uv2_scale;
uniform vec3 uv2_offset;

void vertex() {
	vec3 normal = MODEL_NORMAL_MATRIX * NORMAL;

	TANGENT = vec3(0.0, 0.0, -1.0) * abs(normal.x);
	TANGENT += vec3(1.0, 0.0, 0.0) * abs(normal.y);
	TANGENT += vec3(1.0, 0.0, 0.0) * abs(normal.z);
	TANGENT = inverse(MODEL_NORMAL_MATRIX) * normalize(TANGENT);

	BINORMAL = vec3(0.0, 1.0, 0.0) * abs(normal.x);
	BINORMAL += vec3(0.0, 0.0, -1.0) * abs(normal.y);
	BINORMAL += vec3(0.0, 1.0, 0.0) * abs(normal.z);
	BINORMAL = inverse(MODEL_NORMAL_MATRIX) * normalize(BINORMAL);

	// UV1 Triplanar: Enabled (with World Triplanar)
	uv1_power_normal = pow(abs(normal), vec3(uv1_blend_sharpness));
	uv1_triplanar_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz * uv1_scale + uv1_offset + TIME * 0.1;
	uv1_power_normal /= dot(uv1_power_normal, vec3(1.0));
	uv1_triplanar_pos *= vec3(1.0, -1.0, 1.0);
}

vec4 triplanar_texture(sampler2D p_sampler, vec3 p_weights, vec3 p_triplanar_pos) {
	vec4 samp = vec4(0.0);
	samp += texture(p_sampler, p_triplanar_pos.xy) * p_weights.z;
	samp += texture(p_sampler, p_triplanar_pos.xz) * p_weights.y;
	samp += texture(p_sampler, p_triplanar_pos.zy * vec2(-1.0, 1.0)) * p_weights.x;
	return samp;
}

void fragment() {
	vec4 albedo_tex = triplanar_texture(texture_albedo, uv1_power_normal, uv1_triplanar_pos);
	ALBEDO = albedo.rgb * albedo_tex.rgb;

	float metallic_tex = dot(triplanar_texture(texture_metallic, uv1_power_normal, uv1_triplanar_pos), metallic_texture_channel);
	METALLIC = metallic_tex * metallic;
	SPECULAR = specular;

	vec4 roughness_texture_channel = vec4(1.0, 0.0, 0.0, 0.0);
	float roughness_tex = dot(triplanar_texture(texture_roughness, uv1_power_normal, uv1_triplanar_pos), roughness_texture_channel);
	ROUGHNESS = roughness_tex * roughness;

	// Normal Map: Enabled
	NORMAL_MAP = triplanar_texture(texture_normal, uv1_power_normal, uv1_triplanar_pos).rgb;
	NORMAL_MAP_DEPTH = normal_scale;

	// Refraction: Enabled (with normal map texture)
	vec3 unpacked_normal = NORMAL_MAP;
	unpacked_normal.xy = unpacked_normal.xy * 2.0 - 1.0;
	unpacked_normal.z = sqrt(max(0.0, 1.0 - dot(unpacked_normal.xy, unpacked_normal.xy)));
	vec3 ref_normal = normalize(mix(
			NORMAL,
			TANGENT * unpacked_normal.x + BINORMAL * unpacked_normal.y + NORMAL * unpacked_normal.z,
			NORMAL_MAP_DEPTH));
	vec2 ref_ofs = SCREEN_UV - ref_normal.xy * dot(triplanar_texture(texture_refraction, uv1_power_normal, uv1_triplanar_pos), refraction_texture_channel) * refraction;

	float ref_amount = 1.0 - albedo.a * albedo_tex.a;

	float refraction_depth_tex = textureLod(depth_texture, ref_ofs, 0.0).r;
	vec4 refraction_view_pos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, refraction_depth_tex, 1.0);
	refraction_view_pos.xyz /= refraction_view_pos.w;

	// If the depth buffer is lower then the model's Z position, use the refracted UV, otherwise use the normal screen UV.
	// At low depth differences, decrease refraction intensity to avoid sudden discontinuities.
	EMISSION += textureLod(screen_texture, mix(SCREEN_UV, ref_ofs, smoothstep(0.0, 1.0, VERTEX.z - refraction_view_pos.z)), ROUGHNESS * 8.0).rgb * ref_amount * EXPOSURE;
	ALBEDO *= 1.0 - ref_amount;
	// Force transparency on the material (required for refraction).
	ALPHA = 1.0;
}
"

[sub_resource type="FastNoiseLite" id="FastNoiseLite_pwi0h"]

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_dhios"]
noise = SubResource("FastNoiseLite_pwi0h")
seamless = true
as_normal_map = true

[sub_resource type="ShaderMaterial" id="ShaderMaterial_5nj82"]
render_priority = 0
shader = SubResource("Shader_03pub")
shader_parameter/albedo = Color(0.14079413, 0.3099451, 0.5570427, 0.5058824)
shader_parameter/albedo_texture_size = Vector2i(0, 0)
shader_parameter/point_size = 1.0
shader_parameter/roughness = 0.0
shader_parameter/metallic_texture_channel = Vector4(1, 0, 0, 0)
shader_parameter/specular = 0.5
shader_parameter/metallic = 0.0
shader_parameter/texture_refraction = SubResource("NoiseTexture2D_dhios")
shader_parameter/refraction = 0.05
shader_parameter/refraction_texture_channel = Vector4(1, 0, 0, 0)
shader_parameter/texture_normal = SubResource("NoiseTexture2D_dhios")
shader_parameter/normal_scale = 1.0
shader_parameter/uv1_blend_sharpness = 1.0
shader_parameter/uv1_scale = Vector3(0.04, 0.04, 0.04)
shader_parameter/uv1_offset = Vector3(0, 0, 0)
shader_parameter/uv2_scale = Vector3(1, 1, 1)
shader_parameter/uv2_offset = Vector3(0, 0, 0)

[sub_resource type="CylinderMesh" id="CylinderMesh_8bf0m"]
material = SubResource("ShaderMaterial_5nj82")
top_radius = 3500.0
bottom_radius = 3500.0
height = 0.5

[sub_resource type="Shader" id="Shader_pwi0h"]
code = "
// NOTE: Shader automatically converted from Godot Engine 4.5.stable's ProceduralSkyMaterial.

shader_type sky;
render_mode use_debanding;

uniform vec4 sky_top_color : source_color = vec4(0.385, 0.454, 0.55, 1.0);
uniform vec4 sky_horizon_color : source_color = vec4(0.646, 0.656, 0.67, 1.0);
uniform float inv_sky_curve : hint_range(1, 100) = 4.0;
uniform vec4 ground_bottom_color : source_color = vec4(0.2, 0.169, 0.133, 1.0);
uniform vec4 ground_horizon_color : source_color = vec4(0.646, 0.656, 0.67, 1.0);
uniform float inv_ground_curve : hint_range(1, 100) = 30.0;
uniform float sun_angle_max = 0.877;
uniform float inv_sun_curve : hint_range(1, 100) = 22.78;
uniform float exposure : hint_range(0, 128) = 1.0;

uniform sampler2D sky_cover : filter_linear, source_color, hint_default_black;
uniform vec4 sky_cover_modulate : source_color = vec4(1.0, 1.0, 1.0, 1.0);

uniform sampler2D cloud_texture;
uniform sampler2D cloud_texture2;
uniform vec2 cloud_direction;
uniform vec2 cloud_direction2;
uniform vec2 cloud_scale;
uniform float cloud_distance;
uniform float cloud_speed;
uniform float cloud_speed2;

void sky() {
	float v_angle = clamp(EYEDIR.y, -1.0, 1.0);
	vec3 sky = mix(sky_top_color.rgb, sky_horizon_color.rgb, clamp(pow(1.0 - v_angle, inv_sky_curve), 0.0, 1.0));

	if (LIGHT0_ENABLED) {
		float sun_angle = dot(LIGHT0_DIRECTION, EYEDIR);
		float sun_size = cos(LIGHT0_SIZE);
		if (sun_angle > sun_size) {
			sky = LIGHT0_COLOR * LIGHT0_ENERGY;
		} else if (sun_angle > sun_angle_max) {
			float c2 = (sun_size - sun_angle) / (sun_size - sun_angle_max);
			sky = mix(sky, LIGHT0_COLOR * LIGHT0_ENERGY, clamp(pow(1.0 - c2, inv_sun_curve), 0.0, 1.0));
		}
	}

	if (LIGHT1_ENABLED) {
		float sun_angle = dot(LIGHT1_DIRECTION, EYEDIR);
		float sun_size = cos(LIGHT1_SIZE);
		if (sun_angle > sun_size) {
			sky = LIGHT1_COLOR * LIGHT1_ENERGY;
		} else if (sun_angle > sun_angle_max) {
			float c2 = (sun_size - sun_angle) / (sun_size - sun_angle_max);
			sky = mix(sky, LIGHT1_COLOR * LIGHT1_ENERGY, clamp(pow(1.0 - c2, inv_sun_curve), 0.0, 1.0));
		}
	}

	if (LIGHT2_ENABLED) {
		float sun_angle = dot(LIGHT2_DIRECTION, EYEDIR);
		float sun_size = cos(LIGHT2_SIZE);
		if (sun_angle > sun_size) {
			sky = LIGHT2_COLOR * LIGHT2_ENERGY;
		} else if (sun_angle > sun_angle_max) {
			float c2 = (sun_size - sun_angle) / (sun_size - sun_angle_max);
			sky = mix(sky, LIGHT2_COLOR * LIGHT2_ENERGY, clamp(pow(1.0 - c2, inv_sun_curve), 0.0, 1.0));
		}
	}

	if (LIGHT3_ENABLED) {
		float sun_angle = dot(LIGHT3_DIRECTION, EYEDIR);
		float sun_size = cos(LIGHT3_SIZE);
		if (sun_angle > sun_size) {
			sky = LIGHT3_COLOR * LIGHT3_ENERGY;
		} else if (sun_angle > sun_angle_max) {
			float c2 = (sun_size - sun_angle) / (sun_size - sun_angle_max);
			sky = mix(sky, LIGHT3_COLOR * LIGHT3_ENERGY, clamp(pow(1.0 - c2, inv_sun_curve), 0.0, 1.0));
		}
	}

	
	
	vec3 ground = mix(ground_bottom_color.rgb, ground_horizon_color.rgb, clamp(pow(1.0 + v_angle, inv_ground_curve), 0.0, 1.0));
	
	vec2 sky_uv = EYEDIR.xz / EYEDIR.y;
	vec3 clouds = texture(cloud_texture, sky_uv * cloud_scale + TIME * cloud_direction * cloud_speed).rgb - texture(cloud_texture2, sky_uv * cloud_scale + TIME * cloud_direction2 * cloud_speed2).rgb;
	clouds = clouds - smoothstep(0.0,EYEDIR.y,cloud_distance);
	clouds = clamp(clouds,0.0,1.0);
	sky += clouds;
	
	COLOR = mix(ground, sky, step(0.0, EYEDIR.y)) * exposure;
}
"

[sub_resource type="FastNoiseLite" id="FastNoiseLite_dhios"]

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_5nj82"]
noise = SubResource("FastNoiseLite_dhios")
seamless = true

[sub_resource type="Gradient" id="Gradient_8bf0m"]

[sub_resource type="FastNoiseLite" id="FastNoiseLite_pvncj"]

[sub_resource type="NoiseTexture2D" id="NoiseTexture2D_cbx02"]
width = 614
height = 614
noise = SubResource("FastNoiseLite_pvncj")
color_ramp = SubResource("Gradient_8bf0m")
seamless = true

[sub_resource type="ShaderMaterial" id="ShaderMaterial_ur6ip"]
shader = SubResource("Shader_pwi0h")
shader_parameter/sky_top_color = Color(0.5278759, 0.72914374, 0.98792154, 1)
shader_parameter/sky_horizon_color = Color(0.6463, 0.6558, 0.6708, 1)
shader_parameter/inv_sky_curve = 3.999999841054287
shader_parameter/ground_bottom_color = Color(0.10902894, 0.088692866, 0.0658072, 1)
shader_parameter/ground_horizon_color = Color(0.6463, 0.6558, 0.6708, 1)
shader_parameter/inv_ground_curve = 30.000000670552268
shader_parameter/sun_angle_max = 0.8660254
shader_parameter/inv_sun_curve = 22.782017
shader_parameter/exposure = 1.0
shader_parameter/sky_cover_modulate = Color(1, 1, 1, 1)
shader_parameter/cloud_texture = SubResource("NoiseTexture2D_5nj82")
shader_parameter/cloud_texture2 = SubResource("NoiseTexture2D_cbx02")
shader_parameter/cloud_direction = Vector2(-1, 1)
shader_parameter/cloud_direction2 = Vector2(1, -1)
shader_parameter/cloud_scale = Vector2(0.1, 0.1)
shader_parameter/cloud_distance = 0.002
shader_parameter/cloud_speed = 0.01
shader_parameter/cloud_speed2 = 0.001

[sub_resource type="Sky" id="Sky_pwi0h"]
sky_material = SubResource("ShaderMaterial_ur6ip")

[sub_resource type="Environment" id="Environment_dhios"]
background_mode = 2
sky = SubResource("Sky_pwi0h")

[sub_resource type="CylinderShape3D" id="CylinderShape3D_dhios"]
height = 5.0
radius = 3500.0

[node name="Map_scene" type="Node3D"]
script = ExtResource("1_dhios")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.3165846, -0.28082943, 0.22320795)
mesh = SubResource("CylinderMesh_8bf0m")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(0.7881934, -0.00010755263, 0.61542755, -0.6154276, -0.00013774533, 0.78819335, 0, -0.99999994, -0.00017476082, 0, 69.6701, 0)
light_energy = 5.0
shadow_enabled = true

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_dhios")

[node name="gun" parent="." instance=ExtResource("1_pwi0h")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, -3.130268)
min_barrel_angle = -80
bullet_speed = 100

[node name="floor" type="StaticBody3D" parent="."]

[node name="CollisionShape3D" type="CollisionShape3D" parent="floor"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -1.985, -2.5, 0)
shape = SubResource("CylinderShape3D_dhios")

[connection signal="fire" from="gun" to="." method="_on_gun_fire"]
